# Comprehensive API Reliability Load Testing Configuration
# Tests concurrent contacts fetching, connection pool saturation, and resource exhaustion scenarios

config:
  target: 'http://localhost:5000'
  phases:
    # Phase 1: Baseline performance
    - duration: 30
      arrivalRate: 5
      name: "Baseline - Normal Load"
    
    # Phase 2: Gradual ramp-up to test deduplication
    - duration: 60
      arrivalRate: 20
      name: "Ramp-up - Test Deduplication"
    
    # Phase 3: High concurrency to test connection pool
    - duration: 120
      arrivalRate: 50
      name: "High Concurrency - Connection Pool Test"
    
    # Phase 4: Resource exhaustion simulation
    - duration: 180
      arrivalRate: 100
      name: "Resource Exhaustion - Stress Test"
    
    # Phase 5: Recovery test
    - duration: 60
      arrivalRate: 10
      name: "Recovery - Post-stress Performance"

  processor: "./api-reliability-load-processor.js"
  
  # Test user pool for concurrent operations
  variables:
    testUsers:
      - email: "loadtest1@example.com"
        password: "password123"
        name: "Load Test User 1"
      - email: "loadtest2@example.com"
        password: "password123"
        name: "Load Test User 2"
      - email: "loadtest3@example.com"
        password: "password123"
      - email: "loadtest4@example.com"
        password: "password123"
        name: "Load Test User 4"
      - email: "loadtest5@example.com"
        password: "password123"
        name: "Load Test User 5"

  # Performance thresholds
  ensure:
    thresholds:
      - http.response_time.p95: 5000  # 95% of requests under 5s
      - http.response_time.p99: 10000 # 99% of requests under 10s
      - http.request_rate: 50         # At least 50 req/s throughput
      - http.codes.200: 0.95          # 95% success rate minimum
      - http.codes.500: 0.02          # Less than 2% server errors

scenarios:
  # Scenario 1: Concurrent Contacts Fetching (40% of traffic)
  - name: "Concurrent Contacts Fetching"
    weight: 40
    flow:
      - function: "setupUser"
      - post:
          url: "/api/auth/login"
          json:
            email: "{{ user.email }}"
            password: "{{ user.password }}"
          capture:
            - json: "$.token"
              as: "authToken"
            - json: "$.user.id"
              as: "userId"
          expect:
            - statusCode: 200
      
      # Multiple rapid contacts requests to test deduplication
      - loop:
          - get:
              url: "/api/contacts"
              headers:
                Authorization: "Bearer {{ authToken }}"
              expect:
                - statusCode: [200, 429] # Accept rate limiting
          - think: 0.1 # Very short delay to create concurrent requests
        count: 5
      
      # Search contacts to test different cache keys
      - get:
          url: "/api/contacts"
          qs:
            search: "test"
          headers:
            Authorization: "Bearer {{ authToken }}"
          expect:
            - statusCode: [200, 429]
      
      - think: 1

  # Scenario 2: Mixed API Operations (30% of traffic)
  - name: "Mixed API Operations"
    weight: 30
    flow:
      - function: "setupUser"
      - post:
          url: "/api/auth/login"
          json:
            email: "{{ user.email }}"
            password: "{{ user.password }}"
          capture:
            - json: "$.token"
              as: "authToken"
            - json: "$.user.id"
              as: "userId"
      
      # Mix of different operations to stress connection pool
      - get:
          url: "/api/contacts"
          headers:
            Authorization: "Bearer {{ authToken }}"
      
      - post:
          url: "/api/contacts"
          headers:
            Authorization: "Bearer {{ authToken }}"
          json:
            name: "Load Test Contact {{ $randomString() }}"
            email: "contact{{ $randomInt(1, 1000) }}@example.com"
      
      - get:
          url: "/api/messages"
          headers:
            Authorization: "Bearer {{ authToken }}"
      
      - think: 2

  # Scenario 3: Authentication Stress (20% of traffic)
  - name: "Authentication Stress"
    weight: 20
    flow:
      - function: "setupUser"
      - post:
          url: "/api/auth/login"
          json:
            email: "{{ user.email }}"
            password: "{{ user.password }}"
          expect:
            - statusCode: [200, 429, 503] # Accept various responses under load
      
      - think: 0.5

  # Scenario 4: Resource Exhaustion Simulation (10% of traffic)
  - name: "Resource Exhaustion Simulation"
    weight: 10
    flow:
      - function: "setupUser"
      - post:
          url: "/api/auth/login"
          json:
            email: "{{ user.email }}"
            password: "{{ user.password }}"
          capture:
            - json: "$.token"
              as: "authToken"
      
      # Rapid-fire requests to exhaust resources
      - loop:
          - get:
              url: "/api/contacts"
              headers:
                Authorization: "Bearer {{ authToken }}"
          - get:
              url: "/api/messages"
              headers:
                Authorization: "Bearer {{ authToken }}"
          - think: 0.05 # Very aggressive timing
        count: 10

# Custom metrics to track
metrics:
  - name: "deduplication_effectiveness"
    unit: "percent"
  - name: "connection_pool_utilization"
    unit: "percent"
  - name: "retry_success_rate"
    unit: "percent"
  - name: "resource_exhaustion_recovery_time"
    unit: "milliseconds"